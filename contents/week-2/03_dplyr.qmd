---
title: "Data manipulation with dplyr"
engine: knitr
---

```{r}
#| class-output: outputcode
#| eval: true
#| include: false
library(tidyverse)
```

<br>
The `dplyr` package is one of the `tidyverse` packages. It greatly simplifies how we work with data frames (tibbles) in R and speeds up any associated computations. `dplyr` uses a **grammar** for data manipulation and working with data frames. This grammar consists of a number of different **verbs**. These verbs allow us to communicate how we are manipulating a data frame so that other people can understand it easily.

For all the examples in this section, we are going to use the wine quality datasets that we used previously. It can be loaded using:
```{r}
#| class-output: outputcode
#| eval: true
df <- read_csv(
    './ressource/wine_quality.csv',
    col_types = 'idddddddddddi'
)
```


## The dplyr verbs

Almost all data analytics projects will require us to use $5$ basic `dplyr` verbs. These are:

- `filter()` - extracts a subset of the rows of a data frame using logical conditions  
- `arrange()` - reorder the rows of a data frame  
- `select()` - extract a subset of the columns of a data frame 
- `mutate()` - add new variables/columns or transform existing variables to a data frame
- `summarise()/summarize()` - calculate summary statistics of different variables in a data frame
    
::: {.callout-note appearance="simple"}
Note that the `filter()` and `arrange()` functions work on the rows of a data frame while the `select()`, `mutate()` and `summarise()` functions manipulate the columns.
:::

Another (very) useful verb is `group_by()`. This performs each of the previous operations by different strata as given by categories or groups (e.g. by notes in the wine quality dataset). The pipe operator, `|>` (default R operator since 4.1) or `%>%` (tidyverse operator), is used to connect several of these verbs together into a pipeline.

::: {.callout-note appearance="simple"}
Note that R 4.1 introduced a native pipe operator `|>`. It mostly replaced the tidyverse operator since. See [here](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe) for an article on the differences between the two.
:::


All of the `dplyr` functions work in a similar way. The first argument is a data frame (or tibble). Subsequent arguments describe what to do with the data frame (or tibble) using the variable names. The result of running the function(s) is a new data frame (or tibble).

::: {.callout-note appearance="simple"}
Note that the data must be in **tidy** format, i.e. one observation per row, one variable per column, one value per cell.
:::

## What is `filter()`?

The `filter()` function extracts subsets of rows from a data frame. It selects the **rows** using logical operators/conditions.  The logical conditions relate to the **columns** of the data frame.


There are two ways to use the `filter()` command. The first is:
```{r}
#| class-output: outputcode
#| eval: false
filter(data, condition_1, condition_2, condition_3)
```

The second uses the pipe:
```{r}
#| class-output: outputcode
#| eval: false
data |> filter(condition_1, condition_2, condition_3)
```

All conditions must be `TRUE` for the row to be extracted.

::: {.callout-note appearance="simple"}

## Example

Let's use the wine quality data to demonstrate. The `tidyverse` packages must also be loaded!

- One condition

To start, we will use a single condition in the `filter()` command. To filter all wines (rows) with alcohol by volume larger than $10$, we use:

```{r}
#| class-output: outputcode
#| eval: true
filter(df, alcohol > 10)
```

We can do exactly the same using the pipe, `|>`:
```{r}
#| class-output: outputcode
#| eval: true
df |> filter(alcohol > 10)
```    

- Two conditions

Next extract wines with a quality equal to $8$ and with alcohol by volume larger than $10$:

```{r}
#| class-output: outputcode
#| eval: true
df |> filter(alcohol > 10, quality == 8)
```

:::

## What is `arrange()`?

The `arrange()` function orders the rows of a data frame. It arranges the rows by the values of selected columns. The default is to arrange the values in ascending order (from smallest to largest).

There are two ways to use the `arrange()` command. The first is:
```{r}
#| class-output: outputcode
#| eval: false
arrange(data, column_1, column_2, column_3)
```

The second uses the pipe:
```{r}
#| class-output: outputcode
#| eval: false
data |> arrange(column_1, column_2, column_3)
```
We will use the second version.

The default arrangement from smallest to largest can be changed using the `desc()` function. `NA` values are automatically sorted to the end.

::: {.callout-note appearance="simple"}

## Example

- Ascending order

To arrange all wines by their fixed acidity:
```{r}
#| class-output: outputcode
#| eval: true
df |> arrange(fixed_acidity)
```

Notice the values in the `bill_length_mm` column. It is much more difficult to do this in base R!

- Descending order

To arrange the rows in descending value of fixed acidity:
```{r}
#| class-output: outputcode
#| eval: true
df |> arrange(desc(fixed_acidity))
```
:::

### Multiple columns

You can also arrange multiple columns using `arrange()`. This works if there are multiple repeating values in column 1, and then column 2 is arranged.

::: {.callout-note appearance="simple"}

## Example

```{r}
#| class-output: outputcode
#| eval: true
df |> arrange(fixed_acidity, volatile_acidity)
```

:::

## What is select()?

The `select()` function is used to select columns of a data frame that you want to focus on. In any data analysis project, you will have a large data frame that contains all of the data. However, for a particular analysis (or part of an analysis) only a subset of these data are needed.

### How to use select()?

There are two ways to use the `select()` command. The first is:
```{r}
#| class-output: outputcode
#| eval: false
#select(data, column_1, column_2, column_3)
```

The second uses the pipe:
```{r}
#| class-output: outputcode
#| eval: false
#data |> select(column_1, column_2, column_3)
```
We will use the second version.

- Example - one column

To select just the bill length from the `penguins` data:
```{r}
#| class-output: outputcode
#| eval: false
#penguins |> select(bill_length_mm)
```

- Example - except one column

To select everything *except* the bill length column:
```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(-bill_length_mm)
```

- Example - multiple columns

To select the bill length and body mass columns:
```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(bill_length_mm, body_mass_g)
```

We can use the minus sign to select everything except these columns:
```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(-bill_length_mm, -body_mass_g)
```

- Example - a range of columns

You can use the `:` to select all columns that are between two columns (inclusive). For the `penguins` data remember that:
```{r}
#| class-output: outputcode
#| eval: true
#names(penguins)
```

There are 8 columns, with names as given above. To extract all the columns between `bill_length_mm` and `flipper_length_mm` (inclusive) use:

```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(bill_length_mm:flipper_length_mm)
```
    
Putting the minus sign in front drops these columns:
```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(-(bill_length_mm:flipper_length_mm))
```

**NOTE**: Brackets around the column names!


### Re-arranging columns

You can also re-arrange the order of the columns using `select()` and `everything()`. To put the `year` column first, followed by everything else:

```{r}
#| class-output: outputcode
#| eval: true
#penguins |> select(year, everything())
```

## What is mutate()?

It is often useful to create new variables that are derived from existing ones in a data frame. The `mutate()` function is used to compute transformations of existing variables (columns) in a data frame. For example, we might want to transform from hours to minutes, millimeters to centimeters, etc. `mutate()` provides a simple interface to achieve this.

### How to use mutate()?

To use `mutate()` with the pipe:
```{r}
#| class-output: outputcode
#| eval: false
# data |> 
#     mutate(
#         new_column_name_1 = func_of_column_name_X,
#         new_column_name_2 = func_of_column_name_Y,
#         new_column_name_3 = func_of_column_name_Z
#     )
```

The transformed `X`, `Y`, `Z` columns will then be stored in new columns with the column names specified on the LHS of the `=`.

- Example - one new variable (column)

We will first convert the bill length in the `penguins` data from mm to cm:
```{r}
#| class-output: outputcode
#| eval: true
# new.penguins <- penguins %>%
#     mutate(bill_length_cm = bill_length_mm / 100) 
```
and store the results in a new data frame (tibble), `new.penguins`

Check the names of `new.penguins`:
```{r}
#| class-output: outputcode
#| eval: true
#names(new.penguins)
```

Extract just the `bill_length_mm` and `bill_length_cm` columns:

```{r}
#| class-output: outputcode
#| eval: true
# new.penguins %>%
#     select(bill_length_mm, bill_length_cm)
```

- Example - two new variables

To convert the bill length and flipper length from mm to cm and store the result in a new data frame `new.penguins`:

```{r}
#| class-output: outputcode
#| eval: true
# new.penguins <- penguins %>%
#     mutate(
#         bill_length_cm = bill_length_mm / 100,
#         flipper_length_cm = flipper_length_mm / 100
#     )
```

Again check the names:
```{r}
#| class-output: outputcode
#| eval: true
# names(new.penguins)
```

- Example - two new variables

Extract the `bill_length_mm`, `bill_length_cm`, `flipper_length_mm` and `flipper_length_cm` columns:

```{r}
#| class-output: outputcode
#| eval: true
# new.penguins |> 
#     select(bill_length_mm, bill_length_cm, flipper_length_mm, flipper_length_cm)
```

## What is summarise()?

The `summarise()` function is used to compute statistical summaries of the variables (columns) or rows in a data frame. It will take a vector of data and reduce it to a single summary statistic, e.g. mean, median, min, max. The `summarise()` function can be used directly, or with the pipe.

### How to use summarise()?

To use `summarise()` with the pipe:
```{r}
#| class-output: outputcode
#| eval: false
# data |> 
#     summarise(
#         summary_1 = summary_func_1(column_name),
#         summary_2 = summary_func_2(column_name),
#         summary_3 = summary_func_3(column_name)
#     )
```
The `data` is the data frame or tibble that you want to summarise. The `summary_1/2/3/etc` values are the names of the summary statistics. The `summary_func_1/2/3/etc` values are the summary functions used, e.g. mean, median, min, max.  The `column_name` is the vector of data to summarise (typically a column(s) of the data frame).

- Example - one summary

To calculate the mean bill length in the `penguins` data:
```{r}
#| class-output: outputcode
#| eval: true
# penguins |> 
#     summarise(
#         mean_bill_len = mean(bill_length_mm, na.rm = TRUE)
#     )
```
This returns a tibble with 1 element, the mean bill length. We could store this into a new object if needed.

- Example - two summaries

Calculate the mean bill length and flipper length:
```{r}
#| class-output: outputcode
#| eval: true
# penguins |> 
#     summarise(
#         mean_bill_len = mean(bill_length_mm, na.rm = TRUE),
#         mean_flipper_len = mean(flipper_length_mm, na.rm = TRUE)
#     )
```
    
This gives a tibble with 1 row and 2 columns (one for the mean of each variable).

You could also use other summary functions, `median()`, `sd()`, `min()`, `max()`, `IQR()`, etc. 

### Calculating grouped summaries

Often `summarise()` is used with the `group_by()` function. `group_by()` allows us to "split" our data into sections as defined by our *grouping* variable, e.g. species. We can then perform calculations on each section separately. When used with `summarise()`, summaries are calculated separately for each of the unique groups created by `group_by()`.

To calculate the mean bill length for each species:
```{r}
#| class-output: outputcode
#| eval: true
# penguins |> 
#     group_by(species) |> 
#     summarise(mean_bill_len = mean(bill_length_mm, na.rm = TRUE))
```
A tibble with 3 rows and 2 columns is returned. The first column contains the group names and the second the corresponding mean values. 

## Additional resources

* The `dplyr` [website](https://dplyr.tidyverse.org).

* `dplyr` [cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).

* [Article](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe) on the difference between the pipes.

<br><br>

::: {style="font-size: 0.875em;"}
Back to [week 02](/weeks/week-2.qmd) ⏎
:::