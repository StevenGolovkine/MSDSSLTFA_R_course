{
  "hash": "6d7225d93b231e6a69b1875946fc1676",
  "result": {
    "markdown": "---\ntitle: \"Memory\"\nengine: knitr\n---\n\n\nHere, we will give a general overview into how the memory is adressed in a computer and in R.\n\n## Organisation of the RAM\n\nThe Random-Access Memory (RAM) is organised as an ordered sequence of boxes, each box can contain a binary digit: $0$ or $1$. The information contained in a box, the smallest quantity of information that can be contained, is called a **bit** (for binary digit). Information is actually often organised in blocks of $8$ boxes.\n\nAnother unit has thus been introduced: the **byte**, which is worth $8$ bits. Note that each block is numbered; the number of a block is called its **memory address**. A memory address is thus an identifier, which designates a specific zone of memory where data (or instructions to run) can be read and stored. This identifier is usually an integer expressed in haxedecimal notation (base $16$).\n\n[Add picture]\n\n## Accessing the memory\n\nTo access a given zone of memory, R uses what is called a **pointer**. A pointer is a variable containing a memory address (it points to the desired memory zone). R does that in a transparent way hidden from the user. At the address contained in a given pointer, we can find for example a data point. Remember that rach data point has a specific type, such as integer, double, etc.\n\nAn integer is coded on $4$ bytes, a double on $8$ bytes, a character on $1$ byte, a logical on $4$ bytes and a complex on $16$ bytes to cite the most common variable types. This is true on a $32$ bit processor and on a $64$ bit processor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3L  # Create the value 3 of type integer.\n```\n:::\n\n\nSo, what happen when we previous command is run? A memory slot of $32$ successive blocks ($4$ bytes of $8$ bits each) is allocated (or reserved) and a pointer is created containing the address of the first of these boxes. Actually, the pointer must not only contain the address of the variable `x` but also its type to know over how many boxes the variable is stored. The pointers are said to be **typed**. When a typed pointer is incremented, i.e., when we need to add one unit to the address it contains, it is not necessarily incremented by $1$, but by the size of the pointed type.\n\n[Add picture]\n\n## Issues with integers\n\nSince a (signed) integer is coded over $4$ bytes, i.e. $32$ bits, the largest integer that can be represented is $2147483647$. Indeed, if the first bit is reserved for the sign, there are $31$ remaining available boxes, or $2^31$ possible arrangements. Counting $0$, the largest available integer is this $2^{31} - 1$:\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(2^31 - 1)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2147483647\n```\n:::\n\n```{.r .cell-code}\n.Machine$integer.max\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2147483647\n```\n:::\n:::\n\n\nIf you try to convert to $2^{31}$ as integer, you will get an `NA`. You need a *double* variable to handle number larger than $2^{31}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(2^31)  \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion to integer range\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nis.double(2^31)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] TRUE\n```\n:::\n:::\n\n\nAs the length of a vector (or matrix) is stored as a signed integer, this result has a very pratical application. You can not create a vector with more than $2^{31} - 1$ elements, whether on a $32$ bit or $64$ bit processor. \n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nRegarding how the variables are stored, it can result in an overflow (or not).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n46360 * 46360  # 46360 is stored as a double.\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2149249600\n```\n:::\n\n```{.r .cell-code}\n46360L * 46360L  # 46360L is stored as an integer.\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in 46360L * 46360L: NAs produced by integer overflow\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] NA\n```\n:::\n:::\n\n\nIt might be tricky when combined with usual mathematical operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:304)  # sum(1:304) is stored as an integer.\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 46360\n```\n:::\n\n```{.r .cell-code}\nsum(1:304) * sum(1:304)  # is a product of integer.\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sum(1:304) * sum(1:304): NAs produced by integer overflow\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] NA\n```\n:::\n\n```{.r .cell-code}\n46360^2  # 46360 is stored as a double\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2149249600\n```\n:::\n\n```{.r .cell-code}\nsum(1:304)^2  # ...\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2149249600\n```\n:::\n:::\n\n\nThe last command, following what happened previously, should have result in an integer overflow warning. The exponent function, however, transforms its arguments into reals and returns a real number. \n:::\n\n## Object size in R\n\nWe may expect that the size of the object `3L` to be $8$ bytes, but it is not actually the case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject.size(3L)  # on a 64 bit processor\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n56 bytes\n```\n:::\n:::\n\n\nIn fact, in R, each object contains a header which takes up some space in the RAM: $24$ bytes on a $32$ bit processor and $40$ bytes on a $64$ bit processor. This header is used to save information of the created object: its type, its length, etc.\n\nWe can find out what kind of processor R is runnig using \n\n::: {.cell}\n\n```{.r .cell-code}\n.Machine$sizeof.pointer\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 8\n```\n:::\n:::\n\n\nThe value $8$ is returned for a $64$ bit processor and the value $4$ for a $32$ bit processor. Nowadays, $32$ bit processor are not really used anymore.\n\n## Additional resources\n\n* The Wikipedia RAM [page](https://en.wikipedia.org/wiki/Random-access_memory).",
    "supporting": [
      "02_memory_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}