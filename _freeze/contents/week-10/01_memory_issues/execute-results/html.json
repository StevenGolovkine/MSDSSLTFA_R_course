{
  "hash": "0b2e58a9985d6d037dc9f9c55536c91e",
  "result": {
    "markdown": "---\ntitle: \"Memory Issues in R\"\nengine: knitr\n---\n\n::: {.cell}\n\n:::\n\n\n## Numerical oddities\n\n### Motivated examples\n\nIn these examples, we will consider at how R is representing floating points.\n(You can re-run the examples on your own laptop to convince yourself.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1.0 - 0.5) == 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(1.0 - 0.9) == 0.1\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] FALSE\n```\n:::\n:::\n\n\nSo, it seems that \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 100 * (1 - 0.34)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Using as.integer(x):  65\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Using floor(x): 65\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Using round(x): 66\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Using floor(x): -1.4210854715202e-14\"\n```\n:::\n:::\n\n\nAll these problems are tightly related to how a computer is working. Understand clearly why these things happen will help you with your R coding.\n\n### Fixed-point representation\n\nFor any $x \\in \\mathbb{R}$, we can write \n$$x = \\sum_{k = -\\infty}^{+\\infty} m_k b^k,$$\n\nwhere the integer $b \\geq 2$ is the **base** (usually, $b = 2$ for a computer) and where the coefficients $m_k$, the **digits**, belongs to the set $\\{0, 1, \\dots, b - 1\\}$, for all $k \\in \\mathbb{Z}$.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nThe number $x = 10.625$ can be written in decimal notation ($b = 10$) as\n$$x = 1 \\times 10^1 + 0 \\times 10^0 + 6 \\times 10^{-1} + 2 \\times 10^{-2} + 5 \\times 10^{-3}.$$\nBy noting that $10.625 = 8 + 2 + 0.5 + 0.125$, we can write the same in binary notation as\n$$x = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 0 \\times 2^0 + 1 \\times 2^{-1} + 0 \\times 2^{-2} + 1 \\times 2^{-3}.$$\nSo the number $10.625$ is written in binary form $1010.101$.\n:::\n\nYou can convert decimal numbers to binary and the opposite using the functions `bin2dec` and `dec2bin` in the provided code source.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbin2dec(1010.101)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.625\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndec2bin(10.625, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"1010.111\"\n```\n:::\n:::\n\n\nSome numbers with a finite base $10$ representation are not **dyadic**, that is they have an infinite base $2$ expansion, e.g. $0.2$. This shows that using fixed-point representation to code numbers in a computer is very costly in terms of **bits**. So, most computers use a **floating point** representation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndec2bin(0.2, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"0.000000000000000000000000000000\"\n```\n:::\n:::\n\n\n### Floating point representation\n\nGiven a base $b$, any real number $x \\in \\mathbb{R}$, can be written as\n$$x = (-1)^s m b^e,$$\nwhere\n\n* **s** is called the sign bit of $x$, and is equal to $0$ or $1$;\n\n* **m** is the significand, or mantissa, and can be written $m = m_1m_2\\cdots m_{\\infty}$ where each $m_k \\in \\{0, 1, \\dots, b - 1\\}$ is called a digit;\n\n* **e** $\\in \\mathbb{Z}$ is called the exponent.\n\n# Additional resources\n",
    "supporting": [
      "01_memory_issues_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}