{
  "hash": "ba362a371e26d4ee23c5229c8706f6ec",
  "result": {
    "markdown": "---\ntitle: \"Functional programming with purrr\"\nengine: knitr\n---\n\n\n\n\n<br>\nThe `purrr` package introduces alternative approaches to the `apply` family of functions, presenting a more streamlined and uniform interface along with predefined return value types. This package enhances the concept of functional programming within R, offering an array of functions that empower users to effortlessly apply operations across data structures. These functions not only simplify the code syntax but also ensure a consistent and predictable output type, thus facilitating smoother integration into various data analysis processes.\n\n`purrr` functions are designed to operate on lists, and remember in R, data frames (tibbles) are stored as lists. As a result, leveraging `purrr` functions in tandem with data frames (tibbles) becomes remarkably advantageous, offering a convenient and efficient approach to data manipulation.\n\nFor all the examples in this section, we are going to use the wine quality dataset that we used previously. It can be loaded using:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_csv(\n    './ressource/wine_quality.csv',\n    col_types = 'idddddddddddi'\n)\n```\n:::\n\n\n## Map functions\n\nAt the heart of the `purrr` package lies its fundamental tool, the `map` function. This function applies a function to every element within a list or vector, producing a corresponding list as output. Importantly, if you apply the `map` function of a data frame, it will apply a function on each column of the data frame.\n\nWhile the `map` function typically yields a list, certain derived functions are tailored to return vectors of the appropriate data type:\n\n* `map_dbl()` returns a double vector.\n\n* `map_int()` returns an integer vector.\n\n* `map_chr()` returns a character vector.\n\n* `map_lgl()` returns a logical vector.\n\n* `map_vec()` returns a vector of the simplest common type.\n\nEach function is build the same way. The first argument is a list and the second argument is a function that can be specified in different ways:\n\n* A named function, e.g. `mean`, `sum`.\n\n* An anonymous function, e.g. `\\(x) mean(x)` or `function(x) sum(x)`.\n\n* A formula, e.g. `~ mean(.x)`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n* To compute the sum of each column and returns a named vector using a named function, we can run\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> map_dbl(sum)  # Using a named function\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n                  id        fixed_acidity     volatile_acidity \n         2112540.000            17198.800             1084.747 \n         citric_acid       residual_sugar            chlorides \n             544.960             4932.100              168.296 \n free_sulfur_dioxide total_sulfur_dioxide              density \n           34861.500           101231.000             2049.313 \n                  pH            sulphates              alcohol \n            6806.530             1318.530            21413.183 \n             quality \n           11762.000 \n```\n:::\n:::\n\n\n* To compute the mean of each column and returns a named vector using an anonymous function, we can run\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> map_dbl(function(x) mean(x))  # Using an anonymous function\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n                  id        fixed_acidity     volatile_acidity \n        1.027500e+03         8.365175e+00         5.276007e-01 \n         citric_acid       residual_sugar            chlorides \n        2.650584e-01         2.398881e+00         8.185603e-02 \n free_sulfur_dioxide total_sulfur_dioxide              density \n        1.695598e+01         4.923687e+01         9.967477e-01 \n                  pH            sulphates              alcohol \n        3.310569e+00         6.413084e-01         1.041497e+01 \n             quality \n        5.720817e+00 \n```\n:::\n:::\n\n\n* To compute the maximum of each column and returns a named vector using a formula function, we can run\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> map_dbl(~ max(.x))  # Using a formula\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n                  id        fixed_acidity     volatile_acidity \n          2055.00000             15.90000              1.58000 \n         citric_acid       residual_sugar            chlorides \n             0.76000             14.00000              0.41400 \n free_sulfur_dioxide total_sulfur_dioxide              density \n            68.00000            289.00000              1.00369 \n                  pH            sulphates              alcohol \n             3.78000              1.95000             14.00000 \n             quality \n             8.00000 \n```\n:::\n:::\n\n\n:::\n\n\nFunctions like `map2()` and its variations are explicitly designed to apply a function to pairs of elements drawn from two lists or vectors. Similarly, if you intend to apply a function to groups of elements stemming from a collection of lists or vectors, the `pmap()` function and its corresponding derivatives are your go-to tools.\n\n## List columns\n\nList-columns are columns of a data frame where each element is a list (or vector) instead of an atomic values. Columns can also be lists of data frames.\n\nA simple way to create list-columns is to group data frames by a variable and then nest the results.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo group the wine quality dataset by the quality of the wine and create a list-columns tibble, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    group_by(quality) |> \n    nest()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 2\n# Groups:   quality [6]\n  quality data               \n    <int> <list>             \n1       6 <tibble [778 × 12]>\n2       7 <tibble [333 × 12]>\n3       5 <tibble [839 × 12]>\n4       4 <tibble [55 × 12]> \n5       8 <tibble [39 × 12]> \n6       3 <tibble [12 × 12]> \n```\n:::\n:::\n\n\n:::\n\nList-columns are useful to apply a function over a group of data. For example, we can run a linear regression per wine quality using the previous dataset.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nUsing the nested dataset, we can create a new variable `lin_reg` defined as the linear regression of `volatile_acidity` onto `fixed_acidity` for each wine quality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    group_by(quality) |> \n    nest() |> \n    mutate(\n        lin_reg = map(data, ~ lm(.x$fixed_acidity ~ .x$volatile_acidity))\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 3\n# Groups:   quality [6]\n  quality data                lin_reg\n    <int> <list>              <list> \n1       6 <tibble [778 × 12]> <lm>   \n2       7 <tibble [333 × 12]> <lm>   \n3       5 <tibble [839 × 12]> <lm>   \n4       4 <tibble [55 × 12]>  <lm>   \n5       8 <tibble [39 × 12]>  <lm>   \n6       3 <tibble [12 × 12]>  <lm>   \n```\n:::\n:::\n\n\nThe results of the linear regressions can be accessed as any other variables.\n\n:::\n\n## Additional resources\n\n* The `purrr` [website](https://purrr.tidyverse.org).\n\n* `purrr` [cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 02](/weeks/week-2.qmd) ⏎\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}