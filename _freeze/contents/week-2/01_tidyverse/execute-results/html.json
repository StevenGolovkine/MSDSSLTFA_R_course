{
  "hash": "4c74737fde9e952a0df92a3c5bae813b",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse philosophy\"\nengine: knitr\n---\n\n\n<br>\nThe `tidyverse` is a collection of R packages that are used throughout the data analytics pipeline. These packages are designed to work together easily for data import, data manipulation, data exploration and data visualisation.\n\n## Installing the tidyverse package\n\nWhen you download and install the `tidyverse` package, you download all of the associated packages. Similiarly when you load the `tidyverse` package, you load (attach) all of the associated packages!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n## Tidy data\n\nThe `tidyverse` packages share the same design philosophy, grammar and data structures. When using these packages, the data are assumed to be in **tidy** format, i.e. are **tidy data** (see [here](http://www.jstatsoft.org/v59/i10/paper) for a paper discussing the merits of tidy data). Tidy data are much easier to work with and you can spend more time answering the data analytic question of interest. Tidy data have a rectangular format (rows and columns) and display 3 key properties:\n\n1. Each variable has its own column.\n2. Each observation has its own row.\n3. Each value has its own cell.\n\n**Tidying** your data to ensure it is in the above format is a vital first step in preparing it for analysis. All the tables are from the `tidyr` package.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo demonstrate, let's look at several different ways of storing data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\nThis table has a row for each country and year, with a separate column for cases and population. In the second table, case and population numbers are in the column *count* and a column *type* distinguishes between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\nThis doubles the number of rows in the data frame! Finally, in the third table, this example has the case number and population combined into a single *rate* column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n\n`table1` is the tidy data version as it has one variable per column.\n\n:::\n\n## A tidy dataframe: `tibble`\n\nPutting data into tidy format provides a consistent framework for using the `tidyverse` suite of packages. By default, these packages use **tibbles** to store the data in tidy format, rather than data frames. Tibbles *are* data frames but have some additional properties that make them easier to work with. You can learn more about tibbles if you wish by typing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette(\"tibble\")\n```\n:::\n\ninto the R console.\n    \n### Creating a tibble\n\nTo create a tibble use the `tibble()` function in place of the `data.frame()` function. In the first week, we saw how to create a data frame using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- data.frame(\n    year = c(1980, 1988, 1996, 1998, 2000, 2002, 1985, 2005),\n    gender = c(\"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\"),\n    wgt = c(71.5, 72.1, 73.7, 74.3, 75.2, 74.7, 89.6, 95.2)\n)\n```\n:::\n\n    \nLet's re-create this using the `tibble()` function:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble <- tibble(\n    year = c(1980, 1988, 1996, 1998, 2000, 2002, 1985, 2005),\n    gender = c(\"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\"),\n    wgt = c(71.5, 72.1, 73.7, 74.3, 75.2, 74.7, 89.6, 95.2)\n)\n```\n:::\n\n\n### Comparing tibbles and data frames\n\n`tibble` provides better printing capabilities than `data.frame`. By default, `tibble` prints the number of observations and columns of the data frame, as well as the type of the columns.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n  year gender  wgt\n1 1980      M 71.5\n2 1988      M 72.1\n3 1996      F 73.7\n4 1998      F 74.3\n5 2000      M 75.2\n6 2002      F 74.7\n```\n:::\n\n```{.r .cell-code}\nhead(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 3\n   year gender   wgt\n  <dbl> <chr>  <dbl>\n1  1980 M       71.5\n2  1988 M       72.1\n3  1996 F       73.7\n4  1998 F       74.3\n5  2000 M       75.2\n6  2002 F       74.7\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nThe output of the `str()` function is roughly the same for both classes:\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n'data.frame':\t8 obs. of  3 variables:\n $ year  : num  1980 1988 1996 1998 2000 ...\n $ gender: chr  \"M\" \"M\" \"F\" \"F\" ...\n $ wgt   : num  71.5 72.1 73.7 74.3 75.2 74.7 89.6 95.2\n```\n:::\n\n```{.r .cell-code}\nstr(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\ntibble [8 × 3] (S3: tbl_df/tbl/data.frame)\n $ year  : num [1:8] 1980 1988 1996 1998 2000 ...\n $ gender: chr [1:8] \"M\" \"M\" \"F\" \"F\" ...\n $ wgt   : num [1:8] 71.5 72.1 73.7 74.3 75.2 74.7 89.6 95.2\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nLooking at the intrinsic attributes (`mode` and `length`, remember), the results are the same for `tibble` and `dataframe`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nmode(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"list\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 3\n```\n:::\n:::\n\n\n:::\n\nSo, really, a `tibble` **IS** a dataframe. But the reverse is not true.\n\n### Subsetting \n\nYou can use the same subsetting rules for tibbles as for data frames, however the format of the output may differ.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo extract the `year` data using the `$` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame$year\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble$year\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n:::\n\n\nBut extracting the `year` data using `[ ]` gives different outputs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame[,\"year\"]  # returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble[,\"year\"]  # returns a tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 8 × 1\n   year\n  <dbl>\n1  1980\n2  1988\n3  1996\n4  1998\n5  2000\n6  2002\n7  1985\n8  2005\n```\n:::\n:::\n\n\nTo match the output we can use `[[ ]]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame[[\"year\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble[[\"year\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n:::\n\n\n:::\n\nRemember, this works because a tibble/data frame is stored as a list! In contrast to a `data.frame`, tibbles adhere to a stricter structure. They completely avoid partial matching and, in cases where you attempt to access a non-existent column, they will raise a warning.\n\n## Additional resources\n\n* The tidyverse [website](https://www.tidyverse.org).\n\n* The tibble [website](https://tibble.tidyverse.org/index.html).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 02](/weeks/week-2.qmd) ⏎\n:::",
    "supporting": [
      "01_tidyverse_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}