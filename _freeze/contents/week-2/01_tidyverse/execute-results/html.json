{
  "hash": "a1359cc96951b92ac6bec65c7a8afb6b",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse philosophy\"\nengine: knitr\n---\n\n\n## What is the tidyverse?\n\nThe `tidyverse` is a collection of R packages that are used throughout the data analytics pipeline. These packages are designed to work together easily for data import, data manipulation, data exploration and data visualisation.\n\n## Installing the tidyverse package\n\nWhen you download and install the `tidyverse` package, you download all of the associated packages. Similiarly when you load the `tidyverse` package, you load (attach) all of the associated packages!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n## Tidy data\n\nThe `tidyverse` packages share the same design philosophy, grammar and data structures. When using these packages, the data are assumed to be in *tidy* format, i.e. are **tidy data** (see [here](http://www.jstatsoft.org/v59/i10/paper) for a paper discussing the merits of tidy data). Tidy data are much easier to work with and you can spend more time answering the data analytic question of interest. Tidy data have a rectangular format (rows and columns) and display 3 key properties:\n\n1. Each variable has its own column\n2. Each observation has its own row\n3. Each value has its own cell\n\n*Tidying* your data to ensure it is in the above format is a vital first step in preparing it for analysis. \n\n## Example\n\n- To demonstrate, let's look at several different ways of storing data:\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\nThis has a row for each country and year, with a separate column for cases and population. Here, case and population numbers are in the column *count* and a column *type* distinguishes between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\nThis doubles the number of rows in the data frame! Finally, this example has the case number and population combined into a single *rate* column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n\n`table1` is the tidy data version as it has one variable per column.\n\n## tibbles\n\nPutting data into tidy format provides a consistent framework for using the `tidyverse` suite of packages. By default, these packages use *tibbles* to store the data in tidy format, rather than data frames. Tibbles *are* data frames but have some additional properties that make them easier to work with. You can learn more about tibbles if you wish by typing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette(\"tibble\")\n```\n:::\n\ninto the R console.\n    \n## Creating a tibble\n\nTo create a tibble use the `tibble()` function in place of the `data.frame()` function. In Section 1.10, we saw how to create a data frame using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- data.frame(\n    Year = c(1980, 1988, 1996, 1998, 2000, 2002, 1985, 2005),\n    Gender = c(\"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\"),\n    Wgt = c(71.5, 72.1, 73.7, 74.3, 75.2, 74.7, 89.6, 95.2)\n)\n```\n:::\n\n    \nLet's re-create this using the `tibble()` function:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble <- tibble(\n    Year = c(1980, 1988, 1996, 1998, 2000, 2002, 1985, 2005),\n    Gender = c(\"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\"),\n    Wgt = c(71.5, 72.1, 73.7, 74.3, 75.2, 74.7, 89.6, 95.2)\n)\n```\n:::\n\n   \n## Comparing tibbles and data frames\n\nLet's compare the outputs of both:\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n  Year Gender  Wgt\n1 1980      M 71.5\n2 1988      M 72.1\n3 1996      F 73.7\n4 1998      F 74.3\n5 2000      M 75.2\n6 2002      F 74.7\n```\n:::\n\n```{.r .cell-code}\nhead(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 3\n   Year Gender   Wgt\n  <dbl> <chr>  <dbl>\n1  1980 M       71.5\n2  1988 M       72.1\n3  1996 F       73.7\n4  1998 F       74.3\n5  2000 M       75.2\n6  2002 F       74.7\n```\n:::\n:::\n\n    \nUsing the `str()` function:\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n'data.frame':\t8 obs. of  3 variables:\n $ Year  : num  1980 1988 1996 1998 2000 ...\n $ Gender: chr  \"M\" \"M\" \"F\" \"F\" ...\n $ Wgt   : num  71.5 72.1 73.7 74.3 75.2 74.7 89.6 95.2\n```\n:::\n\n```{.r .cell-code}\nstr(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\ntibble [8 × 3] (S3: tbl_df/tbl/data.frame)\n $ Year  : num [1:8] 1980 1988 1996 1998 2000 ...\n $ Gender: chr [1:8] \"M\" \"M\" \"F\" \"F\" ...\n $ Wgt   : num [1:8] 71.5 72.1 73.7 74.3 75.2 74.7 89.6 95.2\n```\n:::\n:::\n\n\nCheck the dimension using `dim()`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 8 3\n```\n:::\n\n```{.r .cell-code}\ndim(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 8 3\n```\n:::\n:::\n\n    \nWhat about `names()` and `row.names()`?\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Year\"   \"Gender\" \"Wgt\"   \n```\n:::\n\n```{.r .cell-code}\nnames(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Year\"   \"Gender\" \"Wgt\"   \n```\n:::\n\n```{.r .cell-code}\nrow.names(my_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\"\n```\n:::\n\n```{.r .cell-code}\nrow.names(my_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\"\n```\n:::\n:::\n\n\n## Subsetting \n\nYou can use the same subsetting rules for tibbles as for data frames, however the format of the output may differ. To extract the `Year` data using the `$` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame$Year\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble$Year\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n:::\n\n\nTo extract the `Year` data using `[ ]` gives different outputs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame[,\"Year\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble[,\"Year\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 8 × 1\n   Year\n  <dbl>\n1  1980\n2  1988\n3  1996\n4  1998\n5  2000\n6  2002\n7  1985\n8  2005\n```\n:::\n:::\n\n    \nTo match the output we can use `[[ ]]`:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame[[\"Year\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n\n```{.r .cell-code}\nmy_tibble[[\"Year\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1980 1988 1996 1998 2000 2002 1985 2005\n```\n:::\n:::\n\n\nRemember, this works because a data frame is stored as a list!\n\n## Additional resources\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}