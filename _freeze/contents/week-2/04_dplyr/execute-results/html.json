{
  "hash": "ed1d63033945a06d177362178b7379dc",
  "result": {
    "markdown": "---\ntitle: \"Data manipulation with dplyr\"\nengine: knitr\n---\n\n\n\n\n<br>\nThe `dplyr` package is one of the `tidyverse` packages. It greatly simplifies how we work with data frames (tibbles) in R and speeds up any associated computations. `dplyr` uses a **grammar** for data manipulation and working with data frames. This grammar consists of a number of different **verbs**. These verbs allow us to communicate how we are manipulating a data frame so that other people can understand it easily.\n\nFor all the examples in this section, we are going to use the wine quality dataset that we used previously. It can be loaded using:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_csv(\n    './ressource/wine_quality.csv',\n    col_types = 'idddddddddddi'\n)\n```\n:::\n\n\n\n## The dplyr verbs\n\nAlmost all data analytics projects will require us to use $5$ basic `dplyr` verbs. These are:\n\n- `filter()` - extracts a subset of the rows of a data frame using logical conditions  \n- `arrange()` - reorder the rows of a data frame  \n- `select()` - extract a subset of the columns of a data frame \n- `mutate()` - add new variables/columns or transform existing variables to a data frame\n- `summarise()/summarize()` - calculate summary statistics of different variables in a data frame\n    \n::: {.callout-note appearance=\"simple\"}\nNote that the `filter()` and `arrange()` functions work on the rows of a data frame while the `select()`, `mutate()` and `summarise()` functions manipulate the columns.\n:::\n\nAnother (very) useful verb is `group_by()`. This performs each of the previous operations by different strata as given by categories or groups (e.g. by notes in the wine quality dataset). The pipe operator, `|>` (default R operator since 4.1) or `%>%` (tidyverse operator), is used to connect several of these verbs together into a pipeline.\n\n::: {.callout-note appearance=\"simple\"}\nNote that R 4.1 introduced a native pipe operator `|>`. It mostly replaced the tidyverse operator since. See [here](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe) for an article on the differences between the two.\n:::\n\n\nAll of the `dplyr` functions work in a similar way. The first argument is a data frame (or tibble). Subsequent arguments describe what to do with the data frame (or tibble) using the variable names. The result of running the function(s) is a new data frame (or tibble).\n\n::: {.callout-note appearance=\"simple\"}\nNote that the data must be in **tidy** format, i.e. one observation per row, one variable per column, one value per cell.\n:::\n\n## What is `filter()`?\n\nThe `filter()` function extracts subsets of rows from a data frame. It selects the **rows** using logical operators/conditions.  The logical conditions relate to the **columns** of the data frame.\n\n\nThere are two ways to use the `filter()` command. The first is:\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data, condition_1, condition_2, condition_3)\n```\n:::\n\n\nThe second uses the pipe:\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> filter(condition_1, condition_2, condition_3)\n```\n:::\n\n\nAll conditions must be `TRUE` for the row to be extracted.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nLet's use the wine quality data to demonstrate. The `tidyverse` packages must also be loaded!\n\n- One condition\n\nTo start, we will use a single condition in the `filter()` command. To filter all wines (rows) with alcohol by volume larger than $10$, we use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(df, alcohol > 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 1,070 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1     0           8               0.5         0.39            2.2    0.073 \n 2     1           9.3             0.3         0.73            2.3    0.092 \n 3     2           7.1             0.51        0.03            2.1    0.059 \n 4     6           7.2             0.87        0               2.3    0.08  \n 5    11          10.4             0.24        0.42            2.4    0.059 \n 6    14           6.4             0.66        0.03            2.2    0.078 \n 7    16          11.5             0.27        0.6             2.3    0.089 \n 8    19           5.6             0.39        0.16            3      0.095 \n 9    23           5.9             0.22        0.01            1.8    0.0410\n10    25           8.2             0.31        0.32            2      0.066 \n# ℹ 1,060 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\nWe can do exactly the same using the pipe, `|>`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> filter(alcohol > 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 1,070 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1     0           8               0.5         0.39            2.2    0.073 \n 2     1           9.3             0.3         0.73            2.3    0.092 \n 3     2           7.1             0.51        0.03            2.1    0.059 \n 4     6           7.2             0.87        0               2.3    0.08  \n 5    11          10.4             0.24        0.42            2.4    0.059 \n 6    14           6.4             0.66        0.03            2.2    0.078 \n 7    16          11.5             0.27        0.6             2.3    0.089 \n 8    19           5.6             0.39        0.16            3      0.095 \n 9    23           5.9             0.22        0.01            1.8    0.0410\n10    25           8.2             0.31        0.32            2      0.066 \n# ℹ 1,060 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\n- Two conditions\n\nNext extract wines with a quality equal to $8$ and with alcohol by volume larger than $10$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> filter(alcohol > 10, quality == 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 37 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1    19           5.6             0.39        0.16            3       0.095\n 2    46           8.7             0.51        0.6             2       0.074\n 3    96          10               0.37        0.42            2       0.079\n 4   129          11.9             0.31        0.49            2.9     0.1  \n 5   195          10.4             0.39        0.73            1.7     0.1  \n 6   244           6.6             0.56        0.29            1.9     0.169\n 7   288           9.3             0.4         0.42            1.7     0.069\n 8   307           9.8             0.84        0.32            2.6     0.074\n 9   336           7.9             0.36        0.33            2.4     0.065\n10   339           5               0.5         0               1.8     0.048\n# ℹ 27 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\n:::\n\n## What is `arrange()`?\n\nThe `arrange()` function orders the rows of a data frame. It arranges the rows by the values of selected columns. The default is to arrange the values in ascending order (from smallest to largest).\n\nThere are two ways to use the `arrange()` command. The first is:\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(data, column_1, column_2, column_3)\n```\n:::\n\n\nThe second uses the pipe:\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> arrange(column_1, column_2, column_3)\n```\n:::\n\nWe will use the second version.\n\nThe default arrangement from smallest to largest can be changed using the `desc()` function. `NA` values are automatically sorted to the end.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n- Ascending order\n\nTo arrange all wines by their fixed acidity:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> arrange(fixed_acidity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1    48           5               0.62        0.13            1.9    0.093 \n 2   339           5               0.5         0               1.8    0.048 \n 3   369           5               0.5         0               1.7    0.066 \n 4   862           5               0.43        0.24            2.5    0.0580\n 5  1484           5               0.4         0.01            2.1    0.118 \n 6  1783           5               0.46        0.11            1.6    0.0560\n 7  1992           5               0.32        0               1.9    0.044 \n 8   210           5.1             0.56        0               1.8    0.057 \n 9  1129           5.1             0.84        0               2.3    0.0580\n10  1200           5.1             0.53        0.04            1.7    0.044 \n# ℹ 2,046 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\nNotice the values in the `bill_length_mm` column. It is much more difficult to do this in base R!\n\n- Descending order\n\nTo arrange the rows in descending value of fixed acidity:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> arrange(desc(fixed_acidity))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1  1426          15.9            0.315        0.49            4.1     0.194\n 2  1401          15.5            0.645        0.49            3.3     0.095\n 3   482          15              0.635        0.49            3.2     0.083\n 4   238          14.3            0.4          0.6             2.1     0.132\n 5  2011          14.3            0.645        0.49            2.2     0.074\n 6   604          13.9            0.49         0.63            3.8     0.077\n 7   218          13.8            0.49         0.63            2.1     0.084\n 8   269          13.8            0.35         0.49            2.8     0.075\n 9   286          13.8            0.615        0.66            3.6     0.08 \n10  1111          13.5            0.35         0.49            1.6     0.084\n# ℹ 2,046 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n:::\n\n### Multiple columns\n\nYou can also arrange multiple columns using `arrange()`. This works if there are multiple repeating values in column 1, and then column 2 is arranged.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> arrange(fixed_acidity, volatile_acidity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 13\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1  1992           5               0.32        0               1.9    0.044 \n 2  1484           5               0.4         0.01            2.1    0.118 \n 3   862           5               0.43        0.24            2.5    0.0580\n 4  1783           5               0.46        0.11            1.6    0.0560\n 5   339           5               0.5         0               1.8    0.048 \n 6   369           5               0.5         0               1.7    0.066 \n 7    48           5               0.62        0.13            1.9    0.093 \n 8  1200           5.1             0.53        0.04            1.7    0.044 \n 9   210           5.1             0.56        0               1.8    0.057 \n10  1129           5.1             0.84        0               2.3    0.0580\n# ℹ 2,046 more rows\n# ℹ 7 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\n:::\n\n## What is `select()`?\n\nThe `select()` function is used to select columns of a data frame that you want to focus on. In any data analysis project, you will have a large data frame that contains all of the data. However, for a particular analysis (or part of an analysis) only a subset of these data are needed.\n\nThere are two ways to use the `select()` command. The first is:\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(data, column_1, column_2, column_3)\n```\n:::\n\n\nThe second uses the pipe:\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> select(column_1, column_2, column_3)\n```\n:::\n\nWe will use the second version.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n- Select one column\n\nTo select just the quality from the wine quality data:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(quality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 1\n   quality\n     <int>\n 1       6\n 2       6\n 3       7\n 4       5\n 5       6\n 6       5\n 7       6\n 8       6\n 9       6\n10       5\n# ℹ 2,046 more rows\n```\n:::\n:::\n\n\n- Select all columns except one\n\nTo select everything *except* the quality column:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(-quality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 12\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1     0           8               0.5         0.39            2.2     0.073\n 2     1           9.3             0.3         0.73            2.3     0.092\n 3     2           7.1             0.51        0.03            2.1     0.059\n 4     3           8.1             0.87        0.22            2.6     0.084\n 5     4           8.5             0.36        0.3             2.3     0.079\n 6     5           9.9             0.51        0.44            2.2     0.111\n 7     6           7.2             0.87        0               2.3     0.08 \n 8     7           7.5             0.43        0.32            1.8     0.066\n 9     8          11.6             0.38        0.55            2.2     0.084\n10     9           7.8             0.78        0.09            2.2     0.049\n# ℹ 2,046 more rows\n# ℹ 6 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>, alcohol <dbl>\n```\n:::\n:::\n\n\n- Select multiple columns\n\nTo select the quality and alcohol columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(alcohol, quality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 2\n   alcohol quality\n     <dbl>   <int>\n 1    12.1       6\n 2    12.8       6\n 3    11.3       7\n 4     9.8       5\n 5     9.5       6\n 6     9.6       5\n 7    11.3       6\n 8     9.7       6\n 9     9.8       6\n10     9.5       5\n# ℹ 2,046 more rows\n```\n:::\n:::\n\n\nWe can use the minus sign to select everything except these columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(-alcohol, -quality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 11\n      id fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1     0           8               0.5         0.39            2.2     0.073\n 2     1           9.3             0.3         0.73            2.3     0.092\n 3     2           7.1             0.51        0.03            2.1     0.059\n 4     3           8.1             0.87        0.22            2.6     0.084\n 5     4           8.5             0.36        0.3             2.3     0.079\n 6     5           9.9             0.51        0.44            2.2     0.111\n 7     6           7.2             0.87        0               2.3     0.08 \n 8     7           7.5             0.43        0.32            1.8     0.066\n 9     8          11.6             0.38        0.55            2.2     0.084\n10     9           7.8             0.78        0.09            2.2     0.049\n# ℹ 2,046 more rows\n# ℹ 5 more variables: free_sulfur_dioxide <dbl>, total_sulfur_dioxide <dbl>,\n#   density <dbl>, pH <dbl>, sulphates <dbl>\n```\n:::\n:::\n\n\n- Select a range of columns\n\nYou can use the `:` to select all columns that are between two columns (inclusive). For the wine quality data remember that:\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n [1] \"id\"                   \"fixed_acidity\"        \"volatile_acidity\"    \n [4] \"citric_acid\"          \"residual_sugar\"       \"chlorides\"           \n [7] \"free_sulfur_dioxide\"  \"total_sulfur_dioxide\" \"density\"             \n[10] \"pH\"                   \"sulphates\"            \"alcohol\"             \n[13] \"quality\"             \n```\n:::\n:::\n\n\nThere are $13$ columns, with names as given above. To extract all the columns between `chlorides` and `pH` (inclusive) use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(chlorides:pH)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 5\n   chlorides free_sulfur_dioxide total_sulfur_dioxide density    pH\n       <dbl>               <dbl>                <dbl>   <dbl> <dbl>\n 1     0.073                  30                   39   0.996  3.33\n 2     0.092                  30                   67   0.999  3.32\n 3     0.059                   3                   12   0.997  3.52\n 4     0.084                  11                   65   0.997  3.2 \n 5     0.079                  10                   45   0.994  3.2 \n 6     0.111                  30                  134   0.998  3.11\n 7     0.08                    6                   18   0.996  3.34\n 8     0.066                  18                   40   0.996  3.3 \n 9     0.084                  17                   40   1.00   3.17\n10     0.049                  13                   29   0.997  3.51\n# ℹ 2,046 more rows\n```\n:::\n:::\n\n\nPutting the minus sign in front drops these columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(-(chlorides:pH))  # note the brackets\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 8\n      id fixed_acidity volatile_acidity citric_acid residual_sugar sulphates\n   <int>         <dbl>            <dbl>       <dbl>          <dbl>     <dbl>\n 1     0           8               0.5         0.39            2.2      0.77\n 2     1           9.3             0.3         0.73            2.3      0.67\n 3     2           7.1             0.51        0.03            2.1      0.73\n 4     3           8.1             0.87        0.22            2.6      0.53\n 5     4           8.5             0.36        0.3             2.3      1.36\n 6     5           9.9             0.51        0.44            2.2      0.54\n 7     6           7.2             0.87        0               2.3      0.6 \n 8     7           7.5             0.43        0.32            1.8      0.43\n 9     8          11.6             0.38        0.55            2.2      0.73\n10     9           7.8             0.78        0.09            2.2      0.49\n# ℹ 2,046 more rows\n# ℹ 2 more variables: alcohol <dbl>, quality <int>\n```\n:::\n:::\n\n\n:::\n\n### Re-arranging columns\n\nYou can also re-arrange the order of the columns using `select()` and `everything()`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo put the `quality` column first, followed by everything else:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> select(quality, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 13\n   quality    id fixed_acidity volatile_acidity citric_acid residual_sugar\n     <int> <int>         <dbl>            <dbl>       <dbl>          <dbl>\n 1       6     0           8               0.5         0.39            2.2\n 2       6     1           9.3             0.3         0.73            2.3\n 3       7     2           7.1             0.51        0.03            2.1\n 4       5     3           8.1             0.87        0.22            2.6\n 5       6     4           8.5             0.36        0.3             2.3\n 6       5     5           9.9             0.51        0.44            2.2\n 7       6     6           7.2             0.87        0               2.3\n 8       6     7           7.5             0.43        0.32            1.8\n 9       6     8          11.6             0.38        0.55            2.2\n10       5     9           7.8             0.78        0.09            2.2\n# ℹ 2,046 more rows\n# ℹ 7 more variables: chlorides <dbl>, free_sulfur_dioxide <dbl>,\n#   total_sulfur_dioxide <dbl>, density <dbl>, pH <dbl>, sulphates <dbl>,\n#   alcohol <dbl>\n```\n:::\n:::\n\n\n:::\n\n## What is `mutate()`?\n\nIt is often useful to create new variables that are derived from existing ones in a data frame. The `mutate()` function is used to compute transformations of existing variables (columns) in a data frame. For example, we might want to transform from hours to minutes, millimeters to centimeters, etc. `mutate()` provides a simple interface to achieve this.\n\nTo use `mutate()` with the pipe:\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n    mutate(\n        new_column_name_1 = func_of_column_name_X,\n        new_column_name_2 = func_of_column_name_Y,\n        new_column_name_3 = func_of_column_name_Z\n    )\n```\n:::\n\n\nThe transformed `X`, `Y`, `Z` columns will then be stored in new columns with the column names specified on the left-hand side of the `=` sign.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nWe will first compute the ratio between `free_sulfur_dioxide` and `total_sulfur_dioxode`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_df <- df %>%\n    mutate(ratio_sulfur_dioxide = free_sulfur_dioxide / total_sulfur_dioxide) \n```\n:::\n\n\nand store the results in a new data frame (tibble), `new_df`.\n\nExtract just the `free_sulfur_dioxide`, `total_sulfur_dioxide` and `ratio_sulfur_dioxide` columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_df %>%\n    select(free_sulfur_dioxide, total_sulfur_dioxide, ratio_sulfur_dioxide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 2,056 × 3\n   free_sulfur_dioxide total_sulfur_dioxide ratio_sulfur_dioxide\n                 <dbl>                <dbl>                <dbl>\n 1                  30                   39                0.769\n 2                  30                   67                0.448\n 3                   3                   12                0.25 \n 4                  11                   65                0.169\n 5                  10                   45                0.222\n 6                  30                  134                0.224\n 7                   6                   18                0.333\n 8                  18                   40                0.45 \n 9                  17                   40                0.425\n10                  13                   29                0.448\n# ℹ 2,046 more rows\n```\n:::\n:::\n\n\n:::\n\n## What is `summarise()`?\n\nThe `summarise()` function is used to compute statistical summaries of the variables (columns) or rows in a data frame. It will take a vector of data and reduce it to a single summary statistic, e.g. mean, median, min, max. The `summarise()` function can be used directly, or with the pipe.\n\nTo use `summarise()` with the pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n    summarise(\n        summary_1 = summary_func_1(column_name),\n        summary_2 = summary_func_2(column_name),\n        summary_3 = summary_func_3(column_name)\n    )\n```\n:::\n\n\nThe `data` is the data frame or tibble that you want to summarise. The `summary_1/2/3/etc` values are the names of the summary statistics. The `summary_func_1/2/3/etc` values are the summary functions used, e.g. mean, median, min, max.  The `column_name` is the vector of data to summarise (typically a column(s) of the data frame).\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo calculate the mean alcohol by volume in the wine quality data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    summarise(\n        mean_alcohol = mean(alcohol, na.rm = TRUE)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 1 × 1\n  mean_alcohol\n         <dbl>\n1         10.4\n```\n:::\n:::\n\n\nThis returns a tibble with $1$ element, the mean alcohol by volume. We could store this into a new object if needed.\n\n:::\n\nYou could also use other summary functions, `median()`, `sd()`, `min()`, `max()`, `IQR()`, etc. \n\n\n### Calculating grouped summaries\n\nOften `summarise()` is used with the `group_by()` function. `group_by()` allows us to \"split\" our data into sections as defined by our *grouping* variable. We can then perform calculations on each section separately. When used with `summarise()`, summaries are calculated separately for each of the unique groups created by `group_by()`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo calculate the mean alcohol by volume for each quality:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    group_by(quality) |> \n    summarise(mean_alcohol = mean(alcohol, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n# A tibble: 6 × 2\n  quality mean_alcohol\n    <int>        <dbl>\n1       3         9.82\n2       4         9.73\n3       5         9.90\n4       6        10.6 \n5       7        11.2 \n6       8        11.5 \n```\n:::\n:::\n\n\nA tibble with $6$ rows and $2$ columns is returned. The first column contains the group names and the second the corresponding mean values. \n\n:::\n\n## Additional resources\n\n* The `dplyr` [website](https://dplyr.tidyverse.org).\n\n* `dplyr` [cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n* [Article](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe) on the difference between the pipes.\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 02](/weeks/week-2.qmd) ⏎\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}