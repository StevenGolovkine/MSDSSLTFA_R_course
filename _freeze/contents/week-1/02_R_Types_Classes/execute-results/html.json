{
  "hash": "3936801bfdd059f24b8df8b9e5a249f1",
  "result": {
    "markdown": "---\ntitle: \"Types and Classes in R\"\nengine: knitr\n---\n\n\n## R types\n\nTypes refer to the basic built-in data types that R understands natively. The most common types are:\n\n- `logical` (a vector of logical (`TRUE/FALSE`) values)\n- `double` (a vector of real numbers, i.e. have decimal places)\n- `character` (a vector of character values)\n- `closure` (for functions)\n- `list` (for list)\n\nYou can access to the type of an object using the `typeof` function.\n\n## Vectors definition\n\nVectors are a sequence of values of the same data types. There are six basic vector types: `logical`, `integer`, `double`, `complex`, `character` and `raw`.\n\nExamples of vectors:\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_vector <- c(1, 2, 3)\ninteger_vector <- c(1L, 2L, 3L)  # Note the difference with the previous vector.\ncharacter_vector <- c(\"apple\", \"banana\", \"peach\")\n```\n:::\n\n\nVector is the most basic data type. Single numbers or strings are vectors of length 1. Note that it is possible to define vectors with length zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_vector <- c()  # Vector of length zero.\n```\n:::\n\n\n## Lists\n\nLists are generic data structures that allows you to store data objects with different types. The **elements** of a list can be any data structure (even other lists).\n\nExamples of lists:\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- list(1, FALSE, \"hello\")\n\nA <- list(\n    a = c(1, 2, 3),\n    b = \"hello\",\n    c = c(TRUE, FALSE)\n)\n```\n:::\n\n\n## R classes\n\nA class represents the structure of an object. It provides essential information about how an object is organized and interpreted by R and how it can be manipulated. Each class has its own set of methods and functions. It permits an object-oriented programming approach. You can define your own classes using the `class` method and define methods for this class using `name_function.name_class`. This feature is particularly convenient to override existing methods.\n\nFor example, we will create a new class for a simple vector and override the `print` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(1, 2, 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(A)  # type of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(A)  # class of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nprint(A)  # print A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1 2 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(A) <- \"my_class\"\n\nprint.my_class <- function(obj) {\n    print(paste(\"Vector: \", obj))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(A)  # type of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(A)  # class of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"my_class\"\n```\n:::\n\n```{.r .cell-code}\nprint(A)  # print A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Vector:  1\" \"Vector:  2\" \"Vector:  3\"\n```\n:::\n:::\n\n\nSo, the type of the object did not change, but we have defined our own class with a particular `print` function.\n\n\n## Additional resources\n\n- R manual by the R Core Team, [Section 3 on objects](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Objects).\n\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 01](/weeks/week-1.qmd) ‚èé\n:::",
    "supporting": [
      "02_R_Types_Classes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}