{
  "hash": "b837e57b203c516b8fd34ed5d6e370c0",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\nengine: knitr\n---\n\n\n## What are functions?\n\nR is a *functional* programming language, but some OOP systems are implemented.\nBig tasks are broken down into smaller pieces, and functions are written to\nperform each of the smaller tasks. Functions are another type of R object\n(`closure`). We have already see many of the built-in functions in R, e.g.\n`c()`, `list()` or `sqrt()`. Writing functions is a core activity of an R\nprogrammer and is used for reproducibility.\n\n## The role of functions\n\nFunctions are often created if a code chunk needs to be evaluated numerous times\nwith different inputs. A function acts as an interface to a set of code via a\nset of parameters that the user specifies. This provides an abstraction of the\nin-depth workings of the code and allows other users to use the code without\nwriting all of it themselves. A function must be written and *loaded* into the\nenvironment before it can be used (as for usual variables). Functions can also\nbe passed as inputs to other functions.\n\n## Advantages of using functions\n\nThere are three advantages to using functions over copying and pasting code:\n\n1.  A function has a name which makes the code easier to understand.\n2.  If you change requirements, code only needs to be updated in one location\n    (the function) versus lots of copied chunks of code.\n3.  Reduces the chance of making copy and paste or update errors.\n\n## Structure of functions\n\nFunctions have some key properties:\n\n1.  **Name** -- every function has a name which is used to *call* the function.\n2.  **Body** -- the code to be executed when the function is called.\n3.  **Arguments** -- a list of input objects that the user needs to specify.\n4.  **Outputs** -- a list of output objects that are returned once the function\n    is run (called).\n\nFunctions are constructed in R as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(argument_1, argument_2, ...) {\n    \n    Body/code\n    \n    Output\n    \n}\n```\n:::\n\n\nYou decide on the name of the function. The `function()` command is used to\ncreate a new function. Inside the `( )`, the inputs (arguments) are specified,\nwith names as appropriate. The body of the function occurs between the `{ }`.\nThe outputs are typically specified at the end of the body of code. Use comments\nto describe what the function does, the inputs expected, and the outputs at the\nstart of the function and throughout the code. The package\n[`roxygen2`](https://roxygen2.r-lib.org) provides functions to nicely format\nyour documentation.\n\n## A first function\n\nTo create a simple function, that takes no arguments and does nothing use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func <- function() {\n    # Empty body\n    \n    # No outputs\n}\n```\n:::\n\n\nTo *call* or execute this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\nNULL\n```\n:::\n:::\n\n\n## Adding a body\n\nCode that you want to be executed when you call a function is called the *body*\nof the function. This can be as simple or as complex as you like. We can also\ncall other functions. Let's modify our function to print something when called:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func <- function() {\n    print(\"Hello, world!\")\n}\n\nfirst_func()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Hello, world!\"\n```\n:::\n:::\n\n\n## Additional resource\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}