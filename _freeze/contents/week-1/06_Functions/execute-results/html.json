{
  "hash": "1002b537692cc49a0ad86661e870e68a",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\nengine: knitr\n---\n\n\n<br>\nR is a **functional** programming language, with some OOP systems implemented.\nBig tasks are broken down into smaller pieces, and functions are written to\nperform each of the smaller tasks. Functions are another mode of R object (`function`). We have already see many of the built-in functions in R, e.g.\n`c()`, `list()` or `sqrt()`. Writing functions is a core activity of an R\nprogrammer and is used for reproducibility.\n\n## The role of functions\n\nFunctions are often created if a code chunk needs to be evaluated numerous times\nwith different inputs. A function acts as an interface to a set of code via a\nset of parameters that the user specifies. This provides an abstraction of the\nin-depth workings of the code and allows other users to use the code without\nwriting all of it themselves. A function must be written and **loaded** into the\nenvironment before it can be used (as for usual variables). Functions can also\nbe passed as inputs to other functions.\n\n## Advantages of using functions\n\nThere are three (main) advantages to using functions over copying and pasting code:\n\n1.  A function has a name which makes the code easier to understand.\n2.  If you change requirements, code only needs to be updated in one location\n    (the function) versus lots of copied chunks of code.\n3.  Reduces the chance of making copy and paste or update errors.\n\n## Structure of functions\n\nFunctions have some key properties:\n\n1.  **Name** -- every function has a name which is used to **call** the function.\n2.  **Body** -- the code to be executed when the function is called.\n3.  **Arguments** -- a list of input objects that the user needs to specify.\n4.  **Outputs** -- a list of output objects that are returned once the function\n    is run (called).\n\nFunctions are constructed in R as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(argument_1, argument_2, ...) {\n    \n    Body/code\n    \n    Output\n    \n}\n```\n:::\n\n\nYou decide on the name of the function. The `function()` command is used to\ncreate a new function. Inside the `( )`, the inputs (arguments) are specified,\nwith names as appropriate. The body of the function occurs between the `{ }`.\nThe outputs are typically specified at the end of the body of code. Use comments\nto describe what the function does, the inputs expected, and the outputs at the\nstart of the function and throughout the code. The package\n[`roxygen2`](https://roxygen2.r-lib.org) provides functions to nicely format\nyour documentation.\n\nOnce the function is loaded in the environment, it can be invoked in several ways\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(1, 'A')\nfunction_name(argument_1 = 1, argument_2 = 'A')\nfunction_name(1, argument_2 = 'A')\n```\n:::\n\n\nArguments can have suitable default values assigned, making it possible to exclude them from the function call if the defaults are applicable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(argument_1, arg_with_default=1, ...) {\n    \n    Body/code\n    \n    Output\n    \n}\n```\n:::\n\n\nSo, the call `function_name(1)` is equivalent to `function_name(1, 1)`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo create a simple function, that takes no arguments and does nothing use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func <- function() {\n    # Empty body\n    \n    # No outputs\n}\n```\n:::\n\n\nTo call or execute this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\nNULL\n```\n:::\n:::\n\n\nNow, let's modify our function to print something when called:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_func <- function() {\n    print(\"Hello, world!\")\n}\n\nfirst_func()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Hello, world!\"\n```\n:::\n:::\n\n:::\n\n## The `return()` statement\n\nIn R, the `return()` statement exists and is used to return a result from a function. By default, R will return the last expression evaluated within the function. So, if your function consists of a sequence of expressions, you don't need to explicitly use `return()`.\n\nIn some case, however, you will need to explicitly return something:\n\n1. **Early stopping**: If you have conditions where you want to exit the function early.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearly_exit <- function(x) {\n    if (x < 0) {\n        return(\"Negative input not allowed!\")\n    }\n    # rest of the function\n}\n```\n:::\n\n\n:::\n\n2. **Multiple returns**: If your function has multiple return points based on different conditions. \n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiple_returns <- function(x) {\n    if (x < 0) {\n        return(\"Negative input not allowed!\")\n    } else if (x == 0) {\n        return(\"Input is zero!\")\n    }\n    # rest of the function\n}\n```\n:::\n\n\n:::\n\n3. **Inside loops**: In iterative structure, you can exit the loop if a certain condition is met.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninside_loops <- function(numbers) {\n    for (num in numbers) {\n        if (num < 0) {\n            return(\"Negative number found\")\n        }\n    }\n    # rest of the function\n}\n```\n:::\n\n\n:::\n\n## Additional resource\n\n- R manual by the R Core Team, [Section 10 on functions](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Writing-your-own-functions).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 01](/weeks/week-1.qmd) ‚èé\n:::",
    "supporting": [
      "06_Functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}