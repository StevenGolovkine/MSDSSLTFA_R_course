{
  "hash": "732335a415f3f0dc0017dd5fcbe4df91",
  "result": {
    "markdown": "---\ntitle: \"Vectors\"\nengine: knitr\n---\n\n\n<br>\nA vector is a single entity consisting of an ordered collection of elements.\n\n## Creating a vector\n\nA vector is created using the `c()` function. To create a numeric vector with the values $10.4, 5.6, 3.1, 6.4,$ and $21.7$, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(10.4, 5.6, 3.1, 6.4, 21.7)  # Numeric vector with 5 elements\nvec  # Print the contents\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.4  5.6  3.1  6.4 21.7\n```\n:::\n:::\n\n\nAs we have seen before, a vector has two intrinsic properties: its `mode` and its `length`.\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nlength(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 5\n```\n:::\n:::\n\n\n\n## Combining vectors\n\nVectors can be combined using the `c()` command.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo combine two copies of the `vec` vector with a zero in the middle place, you would use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(vec, 0, vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n [1] 10.4  5.6  3.1  6.4 21.7  0.0 10.4  5.6  3.1  6.4 21.7\n```\n:::\n:::\n\n\n:::\n\nBe careful, if you try to combine vectors with different type, the type of the resulting vector will be the most general one.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nWhen combine numbers and characters, the numbers are converted to characters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(vec, \"Mary\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"10.4\" \"5.6\"  \"3.1\"  \"6.4\"  \"21.7\" \"Mary\"\n```\n:::\n:::\n\n\n:::\n\n## Indexing vectors\n\nAccessing to specific element(s) of a vector is possible using the `[]` operator. Note that, in R, the indexing of a vector starts at $1$ (unlike most programming language that start at $0$).\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n`vec[2]` will return the second element of the vector `vec`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 5.6\n```\n:::\n:::\n\n\n:::\n\nSpecifying negative values in the indices will drop that element(s).\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.4  3.1  6.4 21.7\n```\n:::\n:::\n\n\n:::\n\nMultiple elements can be accessed by supplying a vector of indices.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo access the first and third elements of `vec`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.4  3.1\n```\n:::\n:::\n\n\n:::\n\nTo access consecutive indices, you can use `:`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo access the first, second and third elements of `vec`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.4  5.6  3.1\n```\n:::\n:::\n\n\n:::\n\nLogical operators can be used for subsetting vectors.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nIf we want to work with just the components of `vec` that are larger than 6:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask <- vec > 6\nvec[mask]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 10.4  6.4 21.7\n```\n:::\n:::\n\n\nIt could be done in one line using `vec[vec > 6]`. R returns the values in `vec` where a `TRUE` is recorded for `vec > 6`.\n\n:::\n\n## Operations\n\nUsual mathematical operators can be carried on vectors:\n\n-   Addition: `+`\n-   Subtraction: `-`\n-   Multiplication: `*`\n-   Division: `/`\n-   Euclidean division: `%%` and `%/%`\n-   Exponentiation: `^`\n\nComputations are (typically) performed **element-wise**.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo calculate the square of `vec`, `vec^2`, we use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 108.16  31.36   9.61  40.96 470.89\n```\n:::\n:::\n\ni.e. R takes each elements of `vec` and calculates `value^2`.\n:::\n\nIf you are unsure if the calculations are element-wise, you should check on some elements. Other examples of common operations are `log()`, `exp()`, `sin()`, `cos()`, etc.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 2.341806 1.722767 1.131402 1.856298 3.077312\n```\n:::\n\n```{.r .cell-code}\nexp(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 3.285963e+04 2.704264e+02 2.219795e+01 6.018450e+02 2.655769e+09\n```\n:::\n\n```{.r .cell-code}\nsin(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] -0.82782647 -0.63126664  0.04158066  0.11654920  0.28705265\n```\n:::\n:::\n\n\n:::\n\n### Vectors of the same length\n\nWe can add, subtract, multiply or divide vectors of the same length easily. In this case, R takes the values in the same locations (e.g. the first element of each vector) and performs the computations.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo add two vectors of the same length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_1 <- c(1, 3, 5, 7, 9)\nvec_2 <- c(0, 2, 4, 6, 8)\n\nvec_1 + vec_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1]  1  5  9 13 17\n```\n:::\n:::\n\n\n:::\n\n### Vector of different lengths\n\nWhen you perform an operation on vectors of unequal lengths, R automatically **recycles** the shorter vector to match the length of the longer one. This recycling process is applied to ensure that the operation can be carried out element-wise across the vectors. If the shorter vector's length is not an exact divisor of the longer vector's length, the replication is done in a circular manner until both vectors have the same length and a warning message is issued. This indicates that the recycling might not be complete and that the operation may not behave as expected.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nLet's look at an example to understand the concept.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_1 <- c(1, 3, 5, 7, 9)\nvec_2 <- c(0, 2)\n\nvec_1 * vec_2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in vec_1 * vec_2: longer object length is not a multiple of shorter\nobject length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1]  0  6  0 14  0\n```\n:::\n:::\n\n\nLet's dive into the different elements of the resulting vector.\n\n-   The first element is `1 * 0 = 0`.\n-   The second element is `3 * 2 = 6`.\n-   The third element is `5 * 0 = 0`.\n-   The fourth element is `7 * 2 = 14`.\n-   The fifth element is `9 * 0 = 0`.\n\nThe version of `vec_2` that was actually multiplied to `vec_1` is therefore:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(0, 2, 0, 2, 0)\n```\n:::\n\n\n:::\n\nRecycling is particularly useful when you want to perform operations on vectors of different lengths without explicitly extending the shorter vector. However, it is important to be cautious when relying on recycling, as it can lead to unexpected results if not used carefully. Always ensure that the recycling behavior aligns with your intended operation.\n\n\n## Additional resources\n\n- R manual by the R Core Team, [Section 2 on vectors](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Simple-manipulations-numbers-and-vectors).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 01](/weeks/week-1.qmd) ‚èé\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}