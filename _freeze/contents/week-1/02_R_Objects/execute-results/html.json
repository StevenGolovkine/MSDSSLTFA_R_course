{
  "hash": "78b4a4189913560fbbc8e0e2a9cb51ec",
  "result": {
    "markdown": "---\ntitle: \"Objects in R\"\nengine: knitr\n---\n\n\n<br>\nThe entities manipulated by R are formally referred to as **objects**.\n\n## Intrinsic attributes\n\nAn object has two intrinsic attributes: its **mode** and its **length**. The **mode** refers to the type of the object, while the **length** represents the number of elements the object can have.\n\n### Mode\n\nThe mode of an object is the basic type of its fundamental components. Vectors must have all their values (or components) of the same mode. Vectors are **atomic** structures as their components have the same type (numeric, complex, logical, character, or raw). Vectors have thus one of the five types without ambiguity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(1, 2, 3)\nmode(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"numeric\"\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\nNote that the terms **mode** and **type** can be used (almost) interchangeably.\n:::\n\nMore complex objects, such as lists or functions, are **recursive** structure (and not atomic). Their individual components may be of any mode (even list or function). The mode of a list is `list` and the mode of a function is `function`.\n\n### Length\n\nThe length of an object defines how many elements the object contains. It can be accessed (and also modify) using the `length` function.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Examples\n\nFirst, we create a simple vector of length $10$. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- 1:10\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nWe then set the length of the vector to be $3$. It cuts all the elements that are in position greater than $3$.\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(A) <- 3\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1 2 3\n```\n:::\n:::\n\n\nFinally, we want this vector to have a length of $6$. R will fill the position $4$ to $6$ of this vector with `NA`. Be careful that it will not recover the previous values, once the length is changed, the values are removed.\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(A) <- 6\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1]  1  2  3 NA NA NA\n```\n:::\n:::\n\n\n:::\n\n### Empty objects\n\nIn R, there is no problem to define empty objects with a particular mode. To create such a vector, the functions are `integer()`, `complex()`, `logical()`, `character()` and `raw()`. You can also define lists using empty vectors. The length of an empty vector is $0$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_vector <- integer()  # Vector of integer of length zero.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(null_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(null_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 0\n```\n:::\n:::\n\n\n\n\n## R classes\n\nA class represents the structure of an object. All objects have a class reported by the `class` function. It provides essential information about how an object is organized and interpreted by R and how it can be manipulated. Each class has its own set of methods and functions. It permits an object-oriented programming approach. You can define your own classes using the `class` method and define methods for this class using `name_function.name_class`. This feature is particularly convenient to override existing methods.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Examples\n\nTo create a new class for a simple vector and override the `print` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(1, 2, 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(A)  # type of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(A)  # class of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nprint(A)  # print A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] 1 2 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(A) <- \"my_class\"\n\nprint.my_class <- function(obj) {\n    print(paste(\"Vector: \", obj))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(A)  # type of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(A)  # class of A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"my_class\"\n```\n:::\n\n```{.r .cell-code}\nprint(A)  # print A\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n[1] \"Vector:  1\" \"Vector:  2\" \"Vector:  3\"\n```\n:::\n:::\n\n\nSo, the type of the object did not change, but we have defined our own class with a particular `print` function.\n\n:::\n\n## Additional resources\n\n- R manual by the R Core Team, [Section 3 on objects](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Objects).\n\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 01](/weeks/week-1.qmd) ‚èé\n:::",
    "supporting": [
      "02_R_Objects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}