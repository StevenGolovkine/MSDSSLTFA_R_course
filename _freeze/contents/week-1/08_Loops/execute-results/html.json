{
  "hash": "833d2b402846b6f2c5c1ab7da9440b44",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Loops\"\nengine: knitr\n---\n\n\n\n<br>\nLoops are chunks of code that run repeatedly until a stopping criterion is reached. There are lots of different types of loops that are available, e.g. `while` loops, `repeat` loops, and `for` loops. We will focus on `for` loops as these are the most common type of loop you will need when programming in R.\n\n::: {.callout-note appearance=\"simple\"}\n\nIt can be better for code efficiency to avoid using loops, using vectorisation for example, but often a loop works just fine!\n\n:::\n\n\n## Structure of for loops\n\nTo loop/iterate through a certain number of repetitions, or carry out the same thing to lots of inputs (e.g. over all columns of a data frame), a `for` loop is used. In R, `for` loops take an **iterator variable** and assign it successive values from a sequence or vector. The general structure of a `for` loop is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (iterator_variable in some_sequence) {\n    # do something\n}\n```\n:::\n\n\n\nOften we use `i` to denote the iterator variable name but any name can be used. Each time the loop is run, `i` then changes value as given by the numbers in `some_sequence`. Typically `i` increments by $1$ (or some integer), but not always.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nFirst, we consider a simple example where we want to print the numbers from $1$ to $10$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n    print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n\n\n:::\n:::\n\n\n\nHere `i` is the iterator variable and the sequence $1, 2, 3, \\dots, 10$ is the vector of values `i` will take on. First `i` is given the value $1$, and the code between the curly brackets is executed. Here $1$ is printed to the screen. Once the code is executed, `i` is then incremented to the next value in the sequence $1, 2, 3, \\dots, 10$, i.e. the number $2$. The code is executed again and $2$ is printed to the screen. The loop repeats until it reaches the final value in the sequence, $10$, executes the code and then exits the loop. \n\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nConsider a vector of characters named `char_vec`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_vec <- c(\"a\", \"b\", \"c\", \"d\")\n```\n:::\n\n\n\nTo print the contents of `char_vec` there are several options. The following three loops all have the same behaviour.\n\n1. Iterate directly through `char_vec` as the previous example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop 1\nfor (i in char_vec) {\n    print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n\n\n:::\n:::\n\n\n    \n\n2. Define a sequence of indices and access each element of `char_vec` using `[ ]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop 2\nfor (i in 1:4) {\n    print(char_vec[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n\n\n:::\n:::\n\n\n\n3. Use `seq_along()` to automatically create a sequence of indices of the correct length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop 3\nfor (i in seq_along(char_vec)) {\n    print(char_vec[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Storing outputs\n\nWhen using `for` loops we often want to store the results of the code we are executing in the loop. Typically, the results will be stored in specific locations in a vector, data frame, or list depending on the value of `i`. \n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nLet's set up a list with $3$ elements, each of which is a numeric vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_list <- list(\n    el_1 = c(1, 2, 3, 4, 5),\n    el_2 = c(3.4, 2.3, 3.1, 4),\n    el_3 = c(19.3, 12.5, 6.1)\n)\n```\n:::\n\n\n\nSay we want to calculate and store the mean of each of the vectors in `data_list`. A `for` loop can be used to do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up an empty numeric vector to store the means. \nmean_vec <- vector(\n    mode = \"numeric\",\n    length = length(data_list)\n)\n\n# Run the for loop \nfor (i in seq_along(data_list)) {\n    mean_vec[i] <- mean(data_list[[i]]) \n}\n\nmean_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1]  3.00000  3.20000 12.63333\n```\n\n\n:::\n:::\n\n\n\n:::\n\nThere are 3 steps in this process:\n\n1. **Output** - set up an empty object to store the results.  \n2. **Sequence** - set up the iterator variable and the sequencing vector.  \n3. **Body** - write the code to execute.\n    \n## Nested loops\n\n`for` loops can also be **nested**, i.e. we can have multiple loops iterating over different indices. For example, we might want to iterate over the rows and columns of a data frame.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nA nested loop is constructed as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- data.frame(var1 = 1:6, var2 = 8:13)\nfor (i in 1:nrow(my_data_frame)) {\n    for (j in 1:ncol(my_data_frame)) {\n        print(my_data_frame[i, j])\n    }   \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n[1] 1\n[1] 8\n[1] 2\n[1] 9\n[1] 3\n[1] 10\n[1] 4\n[1] 11\n[1] 5\n[1] 12\n[1] 6\n[1] 13\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Implicit looping\n\nR has an in-built family of functions which implement looping in a compact and efficient way. The main functions in this family are:  \n  \n* `lapply()` - loop over a list and evaluate a function on each element.\n* `sapply()` - same as `lapply()` by tries to simplify the result by returning a vector, matrix or array.\n* `tapply()` - apply a function over subsets of a vector.\n* `apply()` - apply a function over the margins of an array.\n* `mapply()` - a multivariate version of `lapply()`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## Example\n\nTo calculate the mean for each element of the data frame `data_list` without using a `for` loop:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_list <- list(\n    el_1 = c(1, 2, 3, 4, 5),\n    el_2 = c(3.4, 2.3, 3.1, 4),\n    el_3 = c(19.3, 12.5, 6.1)\n)\nsapply(data_list, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.outputcode}\n    el_1     el_2     el_3 \n 3.00000  3.20000 12.63333 \n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Additional resource\n\n- R manual by the R Core Team, [Section 9 on repetitive execution](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Repetitive-execution).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\n[Back](/weeks/week-1.qmd) ‚èé\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}