{
  "hash": "35dd04361037897e2e316f3e8c0c4f1b",
  "result": {
    "markdown": "---\ntitle: \"Simulation of linear models\"\nengine: knitr\n---\n\n\n\n\n<br>\nSimulating linear models is a straightforward process. We generate artificial data using known model parameters and random noise. By specifying the model equation, coefficients, and error structure, we can create datasets that mimic real-world scenarios. This approach is valuable for testing statistical techniques, evaluating model assumptions, and understanding the behavior of linear models under different conditions.\n\nThis section is adapted from the R Programming for Data Science [book](https://bookdown.org/rdpeng/rprogdatascience/simulation.html#simulating-a-linear-model).\n\n## A simple linear model\n\nSuppose that we are interested by the relationship between height and circumference of a tree. We would like to model the height as a function of the circumference and some random noise:\n$$\\text{height} = f(\\text{circumference}) + \\epsilon$$\n\nWe may assume that the function $f$ is linear. We have then the following model:\n$$y = \\beta_0 + \\beta_1 x + \\epsilon,$$\n\nwhere $\\epsilon \\sim \\mathcal{N}(0, 1)$. We assume that the circumference of a tree is uniform between $30$ and $70$ centimeters. We fix $\\beta_0 = 9$ (the height if the circumference is equal to $0$) and $\\beta_1 = 0.25$ (when the circumference of the tree grows by $1$cm, its height grows by $0.25$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nn <- 100\nx <- runif(n, 30, 70)\neps <- rnorm(n, 0, 1)\ny <- 9 + 0.25 * x + eps\n\nggplot() +\n  geom_point(aes(x = x, y = y)) +\n  xlab(\"Circumference\") +\n  ylab(\"Height\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](04_models_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWe can simulate more complex models by adding more features (`x`) or their transformations (`x^2`, `log(x)`, ...), changing the distribution of the features or of the noise.\n\n## A count linear model\n\nAs we previously saw, count data are often modelled with a Poisson distribution. We will generate data for this type of model. Let's generate data using the following model:\n$$Y \\sim \\mathcal{P}(\\mu) \\quad \\text{and}\\quad \\log\\mu = \\beta_0 + \\beta_1 x + \\epsilon,$$\nwhere $\\epsilon = \\mathcal{N}(0, 0.0625)$. We fix $\\beta_0 = 0.5$ and $\\beta_1 = 0.3$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nn <- 1000\nx <- runif(n, -1, 1)\neps <- rnorm(n, 0, 0.25)\nmu <- 0.5 + 0.3 * x + eps\ny <- rpois(n, exp(mu))\n\nggplot() +\n  geom_point(aes(x = x, y = y)) +\n  xlab(\"\") +\n  ylab(\"\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](04_models_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nWe can fit a Poisson log-linear model to the generate data to see if we are able to retrieve the coefficients we fixed. We use the `glm` function in R to do so. The results seem pretty good!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglm(y ~ x, family = poisson(link = \"log\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.outputcode}\n\nCall:  glm(formula = y ~ x, family = poisson(link = \"log\"))\n\nCoefficients:\n(Intercept)            x  \n     0.5621       0.3085  \n\nDegrees of Freedom: 999 Total (i.e. Null);  998 Residual\nNull Deviance:\t    1307 \nResidual Deviance: 1250 \tAIC: 3325\n```\n:::\n:::\n\n\n\n## Additional resources\n\n* R Programming for Data Science [book](https://bookdown.org/rdpeng/rprogdatascience/).\n\n<br><br>\n\n::: {style=\"font-size: 0.875em;\"}\nBack to [week 08](/weeks/week-8.qmd) ‚èé\n:::",
    "supporting": [
      "04_models_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}